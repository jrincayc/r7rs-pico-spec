\chapter{Standard Libraries}
\label{stdlibraries}

%% Note, this is used to generate stdmod.tex.  The bindings could be
%% extracted automatically from the document, but this lets us choose
%% the ordering and optionally format manually where needed.

This section lists the exports provided by the standard libraries.  The
libraries are factored so as to separate features which might not be
supported by all implementations, or which might be expensive to load.

The {\cf scheme} library prefix is used for all standard libraries, and
is reserved for use by future standards.

\textbf{Base Library}

The \texttt{(scheme base)} library exports many of the procedures and
syntax bindings that are traditionally associated with Scheme.
The division between the base library and the other standard libraries is
based on use, not on construction. In particular, some facilities that are
typically implemented as primitives by a compiler or the run-time system
rather than in terms of other standard procedures or syntax are
not part of the base library, but are defined in separate libraries.
By the same token, some exports of the base library are implementable
in terms of other exports.  They are redundant in the strict sense of
the word, but they capture common patterns of usage, and are therefore
provided as convenient abbreviations.

\begin{scheme}
{\cf *}                       {\cf +}
{\cf -}                       {\cf ...}
{\cf /}                       {\cf <}
{\cf <=}                      {\cf =}
{\cf =>}                      {\cf >}
{\cf >=}                      {\cf \_}
{\cf abs}                     {\cf and}
{\cf append}                  {\cf apply}
{\cf assoc}                   {\cf assq}
{\cf assv}                    {\cf begin}
{\cf binary-port?\ }           {\cf boolean=?}
{\cf boolean?\ }               {\cf bytevector}
{\cf bytevector-append}       {\cf bytevector-copy}
{\cf bytevector-copy!}        {\cf bytevector-length}
{\cf bytevector-u8-ref}       {\cf bytevector-u8-set!}
{\cf bytevector?\ }            {\cf caar}
{\cf cadr}
{\cf call-with-current-continuation}
{\cf call-with-port}          {\cf call-with-values}
{\cf call/cc}                 {\cf car}
{\cf case}                    {\cf cdar}
{\cf cddr}                    {\cf cdr}
{\cf ceiling}                 {\cf char->integer}
{\cf char-ready?\ }            {\cf char<=?}
{\cf char<?\ }                 {\cf char=?}
{\cf char>=?\ }                {\cf char>?}
{\cf char?\ }                  {\cf close-input-port}
{\cf close-output-port}       {\cf close-port}
{\cf complex?\ }               {\cf cond}
{\cf cond-expand}             {\cf cons}
{\cf current-error-port}      {\cf current-input-port}
{\cf current-output-port}     {\cf define}
{\cf define-record-type}      {\cf define-syntax}
{\cf define-values}           {\cf denominator}
{\cf do}                      {\cf dynamic-wind}
{\cf else}                    {\cf eof-object}
{\cf eof-object?\ }            {\cf eq?}
{\cf equal?\ }                 {\cf eqv?}
{\cf error}                   {\cf error-object-irritants}
{\cf error-object-message}    {\cf error-object?}
{\cf even?\ }                  {\cf exact}
{\cf exact-integer-sqrt}      {\cf exact-integer?}
{\cf exact?\ }                 {\cf expt}
{\cf features}                {\cf file-error?}
{\cf floor}                   {\cf floor-quotient}
{\cf floor-remainder}         {\cf floor/}
{\cf flush-output-port}       {\cf for-each}
{\cf gcd}                     {\cf get-output-bytevector}
{\cf get-output-string}       {\cf guard}
{\cf if}                      {\cf include}
{\cf include-ci}              {\cf inexact}
{\cf inexact?\ }               {\cf input-port-open?}
{\cf input-port?\ }            {\cf integer->char}
{\cf integer?\ }               {\cf lambda}
{\cf lcm}                     {\cf length}
{\cf let}                     {\cf let*}
{\cf let*-values}             {\cf let-syntax}
{\cf let-values}              {\cf letrec}
{\cf letrec*}                 {\cf letrec-syntax}
{\cf list}                    {\cf list->string}
{\cf list->vector}            {\cf list-copy}
{\cf list-ref}                {\cf list-set!}
{\cf list-tail}               {\cf list?}
{\cf make-bytevector}         {\cf make-list}
{\cf make-parameter}          {\cf make-string}
{\cf make-vector}             {\cf map}
{\cf max}                     {\cf member}
{\cf memq}                    {\cf memv}
{\cf min}                     {\cf modulo}
{\cf negative?\ }              {\cf newline}
{\cf not}                     {\cf null?}
{\cf number->string}          {\cf number?}
{\cf numerator}               {\cf odd?}
{\cf open-input-bytevector}   {\cf open-input-string}
{\cf open-output-bytevector}  {\cf open-output-string}
{\cf or}                      {\cf output-port-open?}
{\cf output-port?\ }           {\cf pair?}
{\cf parameterize}            {\cf peek-char}
{\cf peek-u8}                 {\cf port?}
{\cf positive?\ }              {\cf procedure?}
{\cf quasiquote}              {\cf quote}
{\cf quotient}                {\cf raise}
{\cf raise-continuable}       {\cf rational?}
{\cf rationalize}             {\cf read-bytevector}
{\cf read-bytevector!}        {\cf read-char}
{\cf read-error?\ }            {\cf read-line}
{\cf read-string}             {\cf read-u8}
{\cf real?\ }                  {\cf remainder}
{\cf reverse}                 {\cf round}
{\cf set!}                    {\cf set-car!}
{\cf set-cdr!}                {\cf square}
{\cf string}                  {\cf string->list}
{\cf string->number}          {\cf string->symbol}
{\cf string->utf8}            {\cf string->vector}
{\cf string-append}           {\cf string-copy}
{\cf string-copy!}            {\cf string-fill!}
{\cf string-for-each}         {\cf string-length}
{\cf string-map}              {\cf string-ref}
{\cf string-set!}             {\cf string<=?}
{\cf string<?\ }               {\cf string=?}
{\cf string>=?\ }              {\cf string>?}
{\cf string?\ }                {\cf substring}
{\cf symbol->string}          {\cf symbol=?}
{\cf symbol?\ }                {\cf syntax-error}
{\cf syntax-rules}            {\cf textual-port?}
{\cf truncate}                {\cf truncate-quotient}
{\cf truncate-remainder}      {\cf truncate/}
{\cf u8-ready?\ }              {\cf unless}
{\cf unquote}                 {\cf unquote-splicing}
{\cf utf8->string}            {\cf values}
{\cf vector}                  {\cf vector->list}
{\cf vector->string}          {\cf vector-append}
{\cf vector-copy}             {\cf vector-copy!}
{\cf vector-fill!}            {\cf vector-for-each}
{\cf vector-length}           {\cf vector-map}
{\cf vector-ref}              {\cf vector-set!}
{\cf vector?\ }                {\cf when}
{\cf with-exception-handler}  {\cf write-bytevector}
{\cf write-char}              {\cf write-string}
{\cf write-u8}                {\cf zero?}
\end{scheme}

\textbf{Case-Lambda Library}

The \texttt{(scheme case-lambda)} library exports the {\cf case-lambda}
syntax.

\begin{scheme}
{\cf case-lambda}
\end{scheme}

\textbf{Char Library}

The \texttt{(scheme char)} library provides the procedures for dealing with
characters that involve potentially large tables when supporting all of Unicode.

\begin{scheme}
{\cf char-alphabetic?\ }       {\cf char-ci<=?}
{\cf char-ci<?\ }              {\cf char-ci=?}
{\cf char-ci>=?\ }             {\cf char-ci>?}
{\cf char-downcase}           {\cf char-foldcase}
{\cf char-lower-case?\ }       {\cf char-numeric?}
{\cf char-upcase}             {\cf char-upper-case?}
{\cf char-whitespace?\ }       {\cf digit-value}
{\cf string-ci<=?\ }           {\cf string-ci<?}
{\cf string-ci=?\ }            {\cf string-ci>=?}
{\cf string-ci>?\ }            {\cf string-downcase}
{\cf string-foldcase}         {\cf string-upcase}
\end{scheme}

\textbf{Complex Library}

The \texttt{(scheme complex)} library exports procedures which are
typically only useful with non-real numbers.

\begin{scheme}
{\cf angle}                   {\cf imag-part}
{\cf magnitude}               {\cf make-polar}
{\cf make-rectangular}        {\cf real-part}
\end{scheme}

\textbf{CxR Library}

The \texttt{(scheme cxr)} library exports twenty-four procedures which
are the compositions of from three to four {\cf car} and {\cf cdr}
operations.  For example {\cf caddar} could be defined by

\begin{scheme}
(define caddar
  (lambda (x) (car (cdr (cdr (car x)))))){\rm.}%
\end{scheme}

The procedures {\cf car} and {\cf cdr} themselves and the four
two-level compositions are included in the base library.  See
section~\ref{listsection}.

\begin{scheme}
{\cf caaaar}                  {\cf caaadr}
{\cf caaar}                   {\cf caadar}
{\cf caaddr}                  {\cf caadr}
{\cf cadaar}                  {\cf cadadr}
{\cf cadar}                   {\cf caddar}
{\cf cadddr}                  {\cf caddr}
{\cf cdaaar}                  {\cf cdaadr}
{\cf cdaar}                   {\cf cdadar}
{\cf cdaddr}                  {\cf cdadr}
{\cf cddaar}                  {\cf cddadr}
{\cf cddar}                   {\cf cdddar}
{\cf cddddr}                  {\cf cdddr}
\end{scheme}

\textbf{Eval Library}

The \texttt{(scheme eval)} library exports procedures for evaluating Scheme
data as programs.

\begin{scheme}
{\cf environment}             {\cf eval}
\end{scheme}

\textbf{File Library}

The \texttt{(scheme file)} library provides procedures for accessing
files.

\begin{scheme}
{\cf call-with-input-file}    {\cf call-with-output-file}
{\cf delete-file}             {\cf file-exists?}
{\cf open-binary-input-file}  {\cf open-binary-output-file}
{\cf open-input-file}         {\cf open-output-file}
{\cf with-input-from-file}    {\cf with-output-to-file}
\end{scheme}

\textbf{Inexact Library}

The \texttt{(scheme inexact)} library exports procedures which are
typically only useful with inexact values.

\begin{scheme}
{\cf acos}                    {\cf asin}
{\cf atan}                    {\cf cos}
{\cf exp}                     {\cf finite?}
{\cf infinite?\ }              {\cf log}
{\cf nan?\ }                   {\cf sin}
{\cf sqrt}                    {\cf tan}
\end{scheme}

\textbf{Lazy Library}

The \texttt{(scheme lazy)} library exports procedures and syntax keywords for lazy evaluation.

\begin{scheme}
{\cf delay}                   {\cf delay-force}
{\cf force}                   {\cf make-promise}
{\cf promise?}
\end{scheme}

\textbf{Load Library}

The \texttt{(scheme load)} library exports procedures for loading
Scheme expressions from files.

\begin{scheme}
{\cf load}
\end{scheme}

\textbf{Process-Context Library}

The \texttt{(scheme process-context)} library exports procedures for
accessing with the program's calling context.

\begin{scheme}
{\cf command-line}            {\cf emergency-exit}
{\cf exit}
{\cf get-environment-variable}
{\cf get-environment-variables}
\end{scheme}

\textbf{Read Library}

The \texttt{(scheme read)} library provides procedures for reading
Scheme objects.

\begin{scheme}
{\cf read}
\end{scheme}

\textbf{Repl Library}

The \texttt{(scheme repl)} library exports the {\cf
  interaction-environment} procedure.

\begin{scheme}
{\cf interaction-environment}
\end{scheme}

\textbf{Time Library}

The \texttt{(scheme time)} library provides access to time-related values.

\begin{scheme}
{\cf current-jiffy}           {\cf current-second}
{\cf jiffies-per-second}
\end{scheme}

\textbf{Write Library}

The \texttt{(scheme write)} library provides procedures for writing
Scheme objects.

\begin{scheme}
{\cf display}                 {\cf write}
{\cf write-shared}            {\cf write-simple}
\end{scheme}

\textbf{R5RS Library}

The \texttt{(scheme r5rs)} library provides the identifiers defined by
\rfivers, except that
{\cf transcript-on} and {\cf transcript-off} are not present.
Note that
the {\cf exact} and {\cf inexact} procedures appear under their \rfivers\ names
{\cf inexact->exact} and {\cf exact->inexact} respectively.
However, if an implementation does not provide a particular library such as the
complex library, the corresponding identifiers will not appear in this
library either.

\begin{scheme}
{\cf *}                       {\cf +}
{\cf -}                       {\cf /}
{\cf <}                       {\cf <=}
{\cf =}                       {\cf >}
{\cf >=}                      {\cf abs}
{\cf acos}                    {\cf and}
{\cf angle}                   {\cf append}
{\cf apply}                   {\cf asin}
{\cf assoc}                   {\cf assq}
{\cf assv}                    {\cf atan}
{\cf begin}                   {\cf boolean?}
{\cf caaaar}                  {\cf caaadr}
{\cf caaar}                   {\cf caadar}
{\cf caaddr}                  {\cf caadr}
{\cf caar}                    {\cf cadaar}
{\cf cadadr}                  {\cf cadar}
{\cf caddar}                  {\cf cadddr}
{\cf caddr}                   {\cf cadr}
{\cf call-with-current-continuation}
{\cf call-with-input-file}    {\cf call-with-output-file}
{\cf call-with-values}        {\cf car}
{\cf case}                    {\cf cdaaar}
{\cf cdaadr}                  {\cf cdaar}
{\cf cdadar}                  {\cf cdaddr}
{\cf cdadr}                   {\cf cdar}
{\cf cddaar}                  {\cf cddadr}
{\cf cddar}                   {\cf cdddar}
{\cf cddddr}                  {\cf cdddr}
{\cf cddr}                    {\cf cdr}
{\cf ceiling}                 {\cf char->integer}
{\cf char-alphabetic?\ }       {\cf char-ci<=?}
{\cf char-ci<?\ }              {\cf char-ci=?}
{\cf char-ci>=?\ }             {\cf char-ci>?}
{\cf char-downcase}           {\cf char-lower-case?}
{\cf char-numeric?\ }          {\cf char-ready?}
{\cf char-upcase}             {\cf char-upper-case?}
{\cf char-whitespace?\ }       {\cf char<=?}
{\cf char<?\ }                 {\cf char=?}
{\cf char>=?\ }                {\cf char>?}
{\cf char?\ }                  {\cf close-input-port}
{\cf close-output-port}       {\cf complex?}
{\cf cond}                    {\cf cons}
{\cf cos}                     {\cf current-input-port}
{\cf current-output-port}     {\cf define}
{\cf define-syntax}           {\cf delay}
{\cf denominator}             {\cf display}
{\cf do}                      {\cf dynamic-wind}
{\cf eof-object?\ }            {\cf eq?}
{\cf equal?\ }                 {\cf eqv?}
{\cf eval}                    {\cf even?}
{\cf exact->inexact}          {\cf exact?}
{\cf exp}                     {\cf expt}
{\cf floor}                   {\cf for-each}
{\cf force}                   {\cf gcd}
{\cf if}                      {\cf imag-part}
{\cf inexact->exact}          {\cf inexact?}
{\cf input-port?\ }            {\cf integer->char}
{\cf integer?\ }               {\cf interaction-environment}
{\cf lambda}                  {\cf lcm}
{\cf length}                  {\cf let}
{\cf let*}                    {\cf let-syntax}
{\cf letrec}                  {\cf letrec-syntax}
{\cf list}                    {\cf list->string}
{\cf list->vector}            {\cf list-ref}
{\cf list-tail}               {\cf list?}
{\cf load}                    {\cf log}
{\cf magnitude}               {\cf make-polar}
{\cf make-rectangular}        {\cf make-string}
{\cf make-vector}             {\cf map}
{\cf max}                     {\cf member}
{\cf memq}                    {\cf memv}
{\cf min}                     {\cf modulo}
{\cf negative?\ }              {\cf newline}
{\cf not}                     {\cf null-environment}
{\cf null?\ }                  {\cf number->string}
{\cf number?\ }                {\cf numerator}
{\cf odd?\ }                   {\cf open-input-file}
{\cf open-output-file}        {\cf or}
{\cf output-port?\ }           {\cf pair?}
{\cf peek-char}               {\cf positive?}
{\cf procedure?\ }             {\cf quasiquote}
{\cf quote}                   {\cf quotient}
{\cf rational?\ }              {\cf rationalize}
{\cf read}                    {\cf read-char}
{\cf real-part}               {\cf real?}
{\cf remainder}               {\cf reverse}
{\cf round}
{\cf scheme-report-environment}
{\cf set!}                    {\cf set-car!}
{\cf set-cdr!}                {\cf sin}
{\cf sqrt}                    {\cf string}
{\cf string->list}            {\cf string->number}
{\cf string->symbol}          {\cf string-append}
{\cf string-ci<=?\ }           {\cf string-ci<?}
{\cf string-ci=?\ }            {\cf string-ci>=?}
{\cf string-ci>?\ }            {\cf string-copy}
{\cf string-fill!}            {\cf string-length}
{\cf string-ref}              {\cf string-set!}
{\cf string<=?\ }              {\cf string<?}
{\cf string=?\ }               {\cf string>=?}
{\cf string>?\ }               {\cf string?}
{\cf substring}               {\cf symbol->string}
{\cf symbol?\ }                {\cf tan}
{\cf truncate}                {\cf values}
{\cf vector}                  {\cf vector->list}
{\cf vector-fill!}            {\cf vector-length}
{\cf vector-ref}              {\cf vector-set!}
{\cf vector?\ }                {\cf with-input-from-file}
{\cf with-output-to-file}     {\cf write}
{\cf write-char}              {\cf zero?}
\end{scheme}
